## INFO

**도메인 모델 패턴**

주문 서비스의 `주문`, `주문 취소` 메소드는 서비스 메소드 내부가 아닌 비즈니스 로직이 대부분 엔티티에 있다. 

즉 ,서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할(엔티티를 조회하고 필요한 메소드들을 호출하는)만을 수행하고, 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 **도메인 모델 패턴** 이라고 한다.

---
**BindingResult**

MemberForm 에서 @NotEmpty 어노테이션 + 컨트롤러의 MemberForm @Valid을 적용시킨 후, View단에서 데이터가 넘어올 때에 validation에 걸리는 경우 
BindingResult에 해당 에러가 담긴다. 또한 Thymeleaf의 th:erros를 통해 @NotEmpty에 작성한 메시지가 노출된다.

---

**merge란?**

영속성 컨텍스트에서 식별자로 *아이템* 을 찾는다. 그 뒤 merge의 파라미터로 넘어온 값들을 *식별자로 찾아놓은 아이템* 의 값들을 모두 변경시킨다.

하지만 merge를 하는 객체의 특정 필드에 set을 하지 않는다면? set되지 않은 필드에는 null이 들어간다. 
따라서 **항상 변경 감지를 사용**해야 한다. 

---

**Query와 Command**

Update API를 생성할 때 강의에서는 `MemberService.update`의 return 값 타입에 Member 객체를 설정하지 않는다. 
이유는 **Command와 Query를 철저히 분리하는 정책** 때문이다. 

만약 `update` 메소드에서 Member객체를 반환한다면 해당 메소드는
**Member의 이름을 업데이트하는 command**와 **변경된 Member를 조회하는 Query**가 같이 있는 꼴이 된다.

> 이 내용은 '객체지향의 사실과 오해 - 조영호' 의 2장, 기계로서의 객체 부분에서 확인할 수 있다.  
---

